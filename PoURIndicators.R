rm(list=ls())
require(dplyr)
require(plyr)
require(tidyr)
require(randomForest)
require(dismo)
wd <- "~/Desktop/eDNA-metadata/"
#wd <- "/home1/alsimons/PoUR"
setwd(wd)
set.seed(1)

#Get environmental files generated by extracting environmental metadata from Google Earth.
GoogleEarthFiles <- list.files(path=wd,pattern='eedataPoURRound')

#Get basic metadata files for the eDNA sampling locations
PoURMetadataFiles <- list.files(path=wd,pattern='PoURMetadataRound')

#Input taxonomic level to aggregate on.  Rank 7 is the most resolved, and Rank 1 is the least.
rank=7

#Iterate over sample rounds and primer sets.
#Generate random forest models predicting the presence/absence of taxa
#given our environmental variables, then evaluate those models using the symmetric extremal dependence index (SEDI).
#Primers
Primers <- c("16S", "18S","CO1","VERT12S","PITS","FITS")
for(i in 2:2){
  for(Primer in Primers){
    #Get basic metadata for the eDNA sampling locations
    PoURMetadataInput <- read.table(PoURMetadataFiles[i], header=TRUE, sep=",",as.is=T,skip=0,fill=TRUE,check.names=FALSE,quote = "\"", encoding = "UTF-8")
    #Remove control samples
    PoURMetadataInput <- PoURMetadataInput[PoURMetadataInput$Sample_or_Control=="Sample" & PoURMetadataInput$Date_Collected!="Control",]
    
    #Keep only certain columns for analysis.
    PoURMetadataInput <- PoURMetadataInput[,c("Sample","Substrate","Site","River_Bottom","Biofilm","Habitat","Depth","Features")]
    #Convert character columns to factors.
    PoURMetadataInput[sapply(PoURMetadataInput, is.character)] <- lapply(PoURMetadataInput[sapply(PoURMetadataInput, is.character)], as.factor)
    #Coerce sample name back to character prior to merging.
    PoURMetadataInput$Sample <- as.character(PoURMetadataInput$Sample)
    
    #Get environmental metadata generated by extracting environmental metadata from Google Earth.
    GoogleEarthInput <- read.table(GoogleEarthFiles[i], header=TRUE, sep=",",as.is=T,skip=0,fill=TRUE,check.names=FALSE,quote = "\"", encoding = "UTF-8")
    #Remove extraneous columns
    GoogleEarthInput$us_l3name <- NULL
    GoogleEarthInput$latitude <- NULL
    GoogleEarthInput$longitude <- NULL
    #Remove control samples.
    GoogleEarthInput <- GoogleEarthInput[GoogleEarthInput$name %in% PoURMetadataInput$Sample,]
    
    #Merge metadata data frames.
    PoURMetadata <- dplyr::left_join(PoURMetadataInput,GoogleEarthInput,by=c("Sample"="name"))
    #Get a list of environmental variables.
    EnvVar <- colnames(PoURMetadata)
    #Remove sample ID from environmental variable list.
    EnvVar <- EnvVar[EnvVar != "Sample"]
    #Add sample name to row names.
    rownames(PoURMetadata) <- PoURMetadata$Sample
    #Remove rows with missing data.
    PoURMetadata <- PoURMetadata[complete.cases(PoURMetadata),]
    
    #Get samples classified using a particular primer.
    SampleFiles <- list.files(path=wd,pattern=paste("_physeq_",Primer,"_dct_noblanks_min20p",sep=""))
    
    #Set taxonomic rank column names.
    TaxonomicRanks <- c("Rank1", "Rank2","Rank3","Rank4","Rank5","Rank6","Rank7")
    #Set selected taxonomic rank for analysis.
    TaxonomicRank <- paste("Rank",rank,sep="")
    
    #Read in sample data classified using a selected primer.
    SampleInput <- read.table(SampleFiles[i], header=TRUE, sep="\t",as.is=T,skip=0,fill=TRUE,check.names=FALSE,quote = "\"", encoding = "UTF-8")
    #Standardize column name
    colnames(SampleInput)<-gsub(paste("R",i,"_",sep=""),"",colnames(SampleInput))
    #Remove control samples from eDNA data.
    SampleInput <- SampleInput[,colnames(SampleInput) %in% c(PoURMetadata$Sample,"sum.taxonomy")]
    #Split taxonomy names into their component ranks.
    SampleInput <- suppressWarnings(tidyr::separate(SampleInput,'sum.taxonomy',TaxonomicRanks,sep=";", extra="drop"))
    #Standardize NA values
    SampleInput[SampleInput=="NA"] <- NA
    SampleInput[SampleInput==""] <- NA
    #Remove all taxonomic rank column except the selected one.
    SampleInput <- SampleInput[, !(names(SampleInput) %in% TaxonomicRanks[!(TaxonomicRanks %in% TaxonomicRank)])]
    #Remove all rows with missing taxonomic data.
    SampleInput <- SampleInput[!is.na(SampleInput[,TaxonomicRank]),]
    #Aggregate sequence reads by taxonomic groups.
    SampleInput <- as.data.frame(aggregate(formula(paste0(". ~ ",TaxonomicRank)),SampleInput,sum,na.action = na.omit))
    #Move taxonomy to row names.
    rownames(SampleInput) <- SampleInput[,TaxonomicRank]
    SampleInput[,TaxonomicRank] <- NULL
    #Remove samples with fewer than 2000 read sequences per sample,
    #and found in more than one and less than all of the samples.
    SampleInput <- SampleInput[,(colSums(SampleInput) > 2000) & colSums(SampleInput != 0) > 1 & colSums(SampleInput != 0) < nrow(SampleInput)]
    #Convert sequence abundance to presence/absence.  Remove singletons and doubletons.
    SampleInput[SampleInput <= 2] <- 0
    SampleInput[SampleInput > 2] <- 1
    #Take the transpose so that the columns are taxa, and the rows are samples.
    SampleInput <- as.data.frame(t(SampleInput))
    #Remove species columns if they only show up in one sample, or in every sample
    SampleInput <- SampleInput[,colSums(SampleInput) > 1 & colSums(SampleInput) < nrow(SampleInput)]
    #Get the list of unique taxonomic groups.
    taxa <- colnames(SampleInput)
    #Insert sample ID column
    SampleInput$Sample <- rownames(SampleInput)

    #Merge eDNA data with environmental metadata.
    FullData <- dplyr::left_join(SampleInput,PoURMetadata,by=c("Sample"))
    #Move sample ID column to row names.
    rownames(FullData) <- FullData$Sample
    FullData$Sample <- NULL
    #Remove rows with missing data.
    FullData <- FullData[complete.cases(FullData),]
    #Determine remaining taxa which show up in two or more samples.
    taxa <- taxa[colnames(FullData[,colSums(FullData[,taxa])>=2]) %in% taxa]
    #Remove taxa columns where they only show up in less than two samples.
    FullData <- FullData[,c(taxa,EnvVar)]
    
    #Define data frames to collect taxonomic groups and their random forest model evaluations.
    tmp <- data.frame(matrix(nrow=1,ncol=2))
    colnames(tmp) <- c("Taxa","SEDI")
    RFEvaluation <- data.frame()
    RFEvaluationTotal <- data.frame()
    #Define data frames to collect relative importance of environmental variables for random forest models.
    RFImportanceTmp <- data.frame()
    RFImportance <- data.frame()
    RFImportanceTotal <- data.frame()
    #Loop through all taxonomic groups and evaluate them as indicators against environmental values.
    for(k in 1:10){
      RFEvaluation <- data.frame()
      for(j in 1:length(taxa)){
        taxon <- taxa[j]
        RFInput <- FullData[,c(taxon,EnvVar)]
        #Randomly select two samples where the taxonomic group is present.
        RFPresenceBaseline <- RFInput[RFInput[,taxon]==1,]
        RFPresenceBaseline <- RFPresenceBaseline[sample(nrow(RFPresenceBaseline),2),]
        #Remove these two samples where the taxonomic group is present.
        RFInput <- RFInput[!(rownames(RFInput) %in% rownames(RFPresenceBaseline)),]
        if(nrow(RFInput)>=5){
          #Construct a training and testing set for the data to run random forest modeling on.
          group <- kfold(RFInput,5)
          RFTrain <- rbind(RFPresenceBaseline[1,],RFInput[group!=1,])
          RFTest <- rbind(RFPresenceBaseline[2,],RFInput[group==1,])
          #Set presence/absence of taxon to a factor.
          RFTrain[,taxon] <- as.factor(RFTrain[,taxon])
          RFTest[,taxon] <- as.factor(RFTest[,taxon])
          #Determine if both the training and testing sets contains both presences and absences.
          TrainingPA <- length(unique(RFTrain[,taxon]))
          TestingPA <- length(unique(RFTest[,taxon]))
          if(TrainingPA > 1 & TestingPA > 1){
            #Run the random forest model using the training data.
            rf1 <- suppressWarnings(randomForest::tuneRF(RFTrain[,EnvVar],RFTrain[,taxon],stepFactor=1,plot=FALSE,doBest=TRUE))
            #Evaluate the random forest model.
            a <- rf1$confusion[2,2] #True positives 
            b <- rf1$confusion[1,2] #False positives
            c <- rf1$confusion[2,1] #False negatives
            d <- rf1$confusion[1,1] #True negatives
            H <- a/(a+c)
            F <- b/(b+d)
            #SEDI: Symmetric extremal dependence index
            SEDI <- (log(F)-log(H)-log(1-F)+log(1-H))/(log(F)+log(H)+log(1-F)+log(1-H))
            tmp$SEDI <- SEDI
            tmp$Taxa <- taxon
            RFEvaluation <- rbind(RFEvaluation,tmp)
            #Calculate the relative importance of random forest variables.
            RFImportanceTmp <- as.data.frame(t(importance(rf1)))
            RFImportanceTmp$Taxa <- taxon
            RFImportance <- rbind(RFImportance,RFImportanceTmp)
            #Print status
            print(paste("Primer:",Primer,"Taxon:",taxon,"Round:",k,"Taxa:",j,"of:",length(taxa)))
          }
        }
      }
      RFEvaluationTotal <- rbind(RFEvaluationTotal,RFEvaluation)
      RFImportanceTotal <- rbind(RFImportanceTotal,RFImportance)
    }
    #Remove rows with missing data.  Summarize results within a given sampling around and primer set.
    RFEvaluationTotal$SEDI[is.nan(RFEvaluationTotal$SEDI)] <- NA
    RFEvaluationSummary <- plyr::ddply(RFEvaluationTotal, .(Taxa), summarize, MeanSEDI=mean(SEDI,na.rm=T), sdSEDI=sd(SEDI,na.rm=T))
    RFEvaluationSummary$MeanSEDI[is.nan(RFEvaluationSummary$MeanSEDI)] <- NA
    RFEvaluationSummary$sdSEDI[is.nan(RFEvaluationSummary$sdSEDI)] <- NA
    RFEvaluationSummary <- RFEvaluationSummary[complete.cases(RFEvaluationSummary),]
    if(nrow(RFEvaluationSummary)>0 & nrow(RFImportanceTotal)>0){
      #Summarize relative importance results.
      RFImportanceSummary <- aggregate(.~Taxa,RFImportanceTotal,sum)
      RFEvaluationSummary <- dplyr::left_join(RFEvaluationSummary,RFImportanceSummary)
      #Output results to a file.
      write.table(RFEvaluationSummary,paste("RFEvaluation",Primer,"Round",i,"Rank",rank,".txt",sep=""),quote=FALSE,sep="\t",row.names = FALSE)
    }
  }
}
